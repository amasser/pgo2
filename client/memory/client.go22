package memory

import (
	"fmt"
	"time"

	"github.com/pinguo/pgo2"
	"github.com/pinguo/pgo2/core"
	"github.com/pinguo/pgo2/value"
)



// Memory Client component, configuration:
// components:
//      memory:
//          gcInterval: "60s"
//          gcMaxItems: 1000
//          shardNum: 1024
func New(config map[string]interface{}) (interface{}, error) {
	memory := &Client{
		gcInterval: defaultGcInterval,
		gcMaxItems: defaultGcMaxItems,
		shardNum:   defaultShardNum,
		hash:       newHash(),
	}

	err := core.ClientConfigure(memory, config)
	if err != nil {
		return nil, err
	}
	memory.Init()

	return memory, nil
}

type Client struct {
	shards     []*Shard
	shardNum   int
	shardMask  uint64
	hash       *hash
	gcInterval time.Duration
	gcMaxItems int
}

func (c *Client) Init() {
	c.shards = make([]*Shard, c.shardNum, c.shardNum)
	for i := 0; i < c.shardNum; i++ {
		c.shards[i] = NewShard(c.gcMaxItems)
	}

	go c.gcLoop()
}

func (c *Client) SetGcInterval(v string) error {
	if gcInterval, e := time.ParseDuration(v); e != nil {
		return fmt.Errorf(errSetProp, "gcInterval", e.Error())
	} else {
		c.gcInterval = gcInterval
	}

	return nil
}

func (c *Client) SetGcMaxItems(gcMaxItems int) {
	if gcMaxItems > 0 {
		c.gcMaxItems = gcMaxItems
	}
}

func (c *Client) SetShardNum(shardNum int) error {
	if shardNum > 0 {
		if !c.powerOfTwo(shardNum) {
			return fmt.Errorf("Shards number must be power of two")
		}
		c.shardMask = uint64(c.shardNum - 1)
		c.shardNum = shardNum
	}

	return nil
}

func (c *Client) powerOfTwo(number int) bool {
	return (number & (number - 1)) == 0
}

func (c *Client) shard(key string) *Shard {
	hashedKey := c.hash.fnv64a(key)
	return c.shards[hashedKey&c.shardMask]
}

func (c *Client) Get(key string) *value.Value {
	shard := c.shard(key)
	return shard.get(key)
}

func (c *Client) MGet(keys []string) map[string]*value.Value {
	result := make(map[string]*value.Value)
	for _, key := range keys {
		shard := c.shard(key)
		result[key] = shard.get(key)
	}
	return result
}

func (c *Client) Set(key string, value interface{}, expire ...time.Duration) bool {
	shard := c.shard(key)
	return shard.set(key, value, expire...)
}

func (c *Client) MSet(items map[string]interface{}, expire ...time.Duration) bool {
	for key, value := range items {
		shard := c.shard(key)
		shard.set(key, value, expire...)
	}
	return true
}

func (c *Client) Add(key string, value interface{}, expire ...time.Duration) bool {
	shard := c.shard(key)
	return shard.add(key, value, expire...)
}

func (c *Client) MAdd(items map[string]interface{}, expire ...time.Duration) bool {
	success := 0
	for key, value := range items {
		shard := c.shard(key)
		if shard.add(key, value, expire...) {
			success++
		}
	}

	return success == len(items)
}

func (c *Client) Del(key string) bool {

	shard := c.shard(key)
	return shard.del(key)
}

func (c *Client) MDel(keys []string) bool {
	success := 0
	for _, key := range keys {
		shard := c.shard(key)
		if shard.del(key) {
			success++
		}
	}

	return success == len(keys)
}

func (c *Client) Exists(key string) bool {
	shard := c.shard(key)
	return shard.Exists(key)
}

func (c *Client) Incr(key string, delta int) int {

	shard := c.shard(key)
	return shard.Incr(key, delta)
}

func (c *Client) gcLoop() {
	defer func() {
		if err := recover(); err != nil {
			pgo2.GLogger().Error("memory.gcLoop err:%s", err)
		}
	}()

	if c.gcInterval < minGcInterval || c.gcInterval > maxGcInterval {
		c.gcInterval = defaultGcInterval
	}

	for {
		<-time.After(c.gcInterval)
		for k, shard := range c.shards {
			func() {
				defer func() {
					if err := recover(); err != nil {
						pgo2.GLogger().Error("memory.shard.clearExpired keyNum:%d err:%s", k, err)
					}
				}()

				if expiredKeys := shard.getExpireKeys(); len(expiredKeys) > 0 {
					shard.clearExpiredKeys(expiredKeys)
				}
			}()

		}

	}
}
